---
layout: post
title: Redis缓存三大问题
gh-repo: youcoding98/youcoding98.github.io
gh-badge: [star, fork, follow]
tags: [Redis]
---
本篇文章介绍了Redis缓存的三大典型问题：缓存穿透、缓存击穿和缓存雪崩。



## 一、缓存穿透
**具体内容**  
查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大,甚至导致物理DB宕机。

**解决方法**  
1. 缓存空对象：  
当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。
若是再次访问该空对象时，就会直接击中缓存，而不是再次数据库。  
**存在问题**：缓存中会存在很多空对象，占用内存空间，浪费资源。  
解决办法：设置空对象的较短的过期时间。  
2. 布隆过滤器：  
是一种基于概率的数据结构（由一个非常大的二进制数组和若干个哈希函数组成），主要用来判断某个元素是否在集合中。不存在漏报，可能存在误报。  
将查询数据的`id`放进布隆过滤器中，当用户请求时，使用布隆过滤器进行判断该id是否存在在布隆过滤器中，不存在，直接返回null。  
**存在问题**：要维持容器中的数据，实时更新布隆过滤器中的数据为最新。  
3. 用户合法性校验：对用户的请求合法性进行校验，拦截恶意请求。  

## 二、缓存击穿 
**具体内容**  
当高并发请求访问Redis中热点数据时，如果数据过期了，会造成缓存击穿的现象，请求都打到了数据库上。  
造成缓存击穿的原因有以下两个：  
1） 该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）  
2） 添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）  
**解决方法**  
1. 热点数据永不过期：  
比如我们可以将某个key的缓存时间设置为25小时，后台有个JOB每隔24小时就去批量刷新一下热点数据  
2. 使用互斥锁：  
出现高并发时，在查询的过程中加锁，只能第一个进来的请求执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存  

## 三、缓存雪崩
**具体内容**  
在某一时间段，缓存集中过期失效，此时无数请求直接绕过缓存，直接请求数据库。  
原因可能是：1)redis宕机；2）大部分数据失效  
**解决方法**
1. 搭建高可用的集群，防止单机的redis宕机  
2. 给缓存设置不同的过期时间  
3. 更新数据，使用互斥锁  
4. 通过双缓存来避免缓存雪崩  

## 参考文献
1. [【进大厂系列】Redis缓存三大问题](https://blog.csdn.net/qq_43255017/article/details/105447230)






